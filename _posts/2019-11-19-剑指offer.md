---
layout:     post
title:      剑指offer
subtitle:   刷题
date:       2019-11-19
author:     WHY
header-img: img/post-bg-debug.png
catalog:    true
tag:
    - Coding
---

## 目录

* 基础知识
    * 1 赋值运算符函数
    * 2 实现Singleton模式
* 数据结构
    * 数组
        * 3 [数组中的重复数字](https://why96.top/2019/11/19/%E5%89%91%E6%8C%87offer/#3-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97)
        * 4 [二维数组中查找目标值](https://why96.top/2019/11/19/%E5%89%91%E6%8C%87offer/#4-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E8%AF%A2%E7%9B%AE%E6%A0%87%E5%80%BC)
    * 字符串
        * 5 [替换空格](https://why96.top/2019/11/19/%E5%89%91%E6%8C%87offer/#5-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC)
    * 链表
        * 6[从尾到头打印链表](https://why96.top/2019/11/19/%E5%89%91%E6%8C%87offer/#6-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8)


## 解析

### 3. 数组中重复的数字

#### 题目描述
* 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

#### 思路
* 从头一次扫描这个数组，当下标为i时，对应的数字为m。首先比较m是否等于i，如果等于，则接着扫描下一个数；如果不等于，则查看下标为m的数字是否等于m，如果等于，即找到重复的数字；如果不相等，则将两者位置交换，使m下标所对应的数字等于m。然后继续按照下标进行搜索，重复上述比较过程直到找到重复的数字。

#### 代码 [GitHub](https://github.com/why2222/offer/blob/master/src/Solution3.java)
```java
public static boolean duplicate2(int numbers[],int length,int [] duplication){
        int tmp;
        for (int i = 0;i < length;i++){
            if(numbers[i] == i){
                continue;
            }else {
                if (numbers[numbers[i]] == numbers[i]){
                    duplication[0] = numbers[i];
                    return true;
                }else {
                    tmp = numbers[numbers[i]];
                    numbers[numbers[i]] = numbers[i];
                    numbers[i] = tmp;
                }
            }
        }
        return false;
    }
```

### 4. 二维数组中查询目标值

#### 题目描述
* 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

#### 思路
* 将二维数组转化成矩形，然后从数组中选取出一个数字，可以分成三种情况进行查找。当选取的数字小于要查找的数字，那么根据数组排序的规则，要向当前位置的右下方继续查找；如果选取的数字大于要查找的数字，那么要向当前位置的左上方继续查找；如果选取的数字等于目标值，结束查找过程。
* 但是从哪一个点开始查找过程是本题解题的关键。把二维数组转化为矩形，假设从中间位置开始查找，不难发现当选取值大于或小于目标值时继续查找的区域有所重叠，故不适用选取中间区域的数作为起始查询位置；若选取`array[0][0]`和`array[array.length-1][array.length-1]`为起始查询位置，无论向哪一侧都是大于或者小于当前选取的数值，无法缩小查找范围，故不能作为起始查找位置。
* 从`array[0][array.length-1]`开始查找，当其大于目标值时，根据大小规则下方一列都被舍弃不用再进行查找，进而向左移动，若`array[0][array.length-2]`小于目标值，则其所在行左边都被舍弃不再进行查找，进而向下移动与`array[1][array.length-2]`进行比较。比较方法同上，依次进行，逐渐将查找区域缩小。

#### 代码 [GitHub](https://github.com/why2222/offer/blob/master/src/SolutionFour.java)
```java
public static boolean Find2(int target,int [][] array){
        boolean found = false;
        int rows,columns;
        rows = columns = array.length;
        if (array.length != 1){
            int row = 0;
            int column = columns - 1;
            while(row < array.length && column >= 0){
                if (array[row][column] == target){
                    found = true;
                    break;
                }else if (array[row][column] > target){
                    column -= 1;
                }else {
                    row += 1;
                }
            }
        }
        return found;
    }
```

### 5. 替换空格

#### 题目描述
* 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

#### 思路
* 使用`StringBuffer`类的方法实现对字符串的获取、删除、插入等操作。
    * `.charAt(index)`:获取index位置的字符。
    * `.delete(index)`:删除index位置的字符。
    * `.insert(index,str)`:将字符串从index位置处插入。
    * `.toString()`:将StringBuffer类型转换为String类型。

#### 代码 [GitHub](https://github.com/why2222/offer/blob/master/src/Solution5.java)
```java
public static String replaceSpace(StringBuffer str){
        String target = "%20";
        for (int i = 0;i < str.length();i++){
            if (str.charAt(i) == ' '){
                str.deleteCharAt(i);
                str.insert(i,target);
            }
        }
        return str.toString();
    }
```

### 6. 从尾到头打印链表

#### 题目描述
* 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。

#### 思路
* 改变链表结构
    * 将链表中节点指针反转过来，然后从头到尾输出即可。但是是否允许在打印链表的时候修改链表结构，取决于面试官或者题目的要求。
* 不改变链表结构
    * 遍历链表，第一个遍历到的节点最后一个输出，最后一个遍历的节点第一个输出。这就是典型的“先进后出”，可以用栈实现这种顺序。
    * 递归：递归在本质上就是一个栈结构，可以利用递归的方法来实现。每访问一个节点时，先输出下一个节点，再输出其本身，即可实现链表的倒序输出。

#### 代码 [GitHub](https://github.com/why2222/offer/blob/master/src/Solution6.java)
```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode){
        ArrayList<Integer> list = new ArrayList<>();
        if (listNode == null){
            return list;
        }
        if (listNode.next != null){
            // 注意：这里不要忘了用接收返回值！！！
            // 如果这里不接收返回值的话，则无法得到次级函数的结果，最后return的只是第一层函数的结果。
            list = printListFromTailToHead2(listNode.next);
        }
        list.add(listNode.val);

        return list;
    }
```

